package com.knitml.elimport static org.apache.commons.lang.StringUtils.* import static org.springframework.util.StringUtils.collectionToCommaDelimitedStringimport org.apache.commons.lang.StringUtils/** * <p>Translates a GroovyKnit file (a file which only has markup builder syntax) * into a Groovy script, following certain rules:</p> *  * <p>The first word on the line always translates to a method call:</p> * <pre> * k2tog                           --> k2tog () * directions { }                  --> directions () { } * </pre> *  * <p>Subsequent words before a curly brace are arguments to * the method call:</p>  * <pre> * useNeedle 'needle1'             --> useNeedle ('needle1') * useNeedles 'needle1' 'needle2'  --> useNeedles ('needle1','needle2') * k to end                        --> k (to,end) * </pre> *  * <p>If a method name ends with a colon, that colon is stripped * <pre> * length: 3 inches                --> length (3,inches) * </pre> *  * <p>A comma, when not located within parentheses, allows multiple * function calls per line:</p> * <pre> * k 1, k2tog                      --> knit (1); k2tog () * k 1,k2tog                       --> knit (1); k2tog () * </pre> *  * <p>When a comma occurs within parentheses, however, it separates * arguments to the method call (i.e. stuff inside of parentheses * are not transformed):</p> * <pre> * useNeedles ('1','2')            --> useNeedles ('1','2') * </pre> *  * <p>If the last argument is a closure, all previous arguments are * fitted into a set of parentheses:</p> * <pre> * instruction 'make-foot' { }     --> instruction ('make-foot') { } * </pre> * * <p>Spaces within quotes do not break up arguments, and escape * characters are allowed:</p> * name 'My Pattern'               --> name ('My Pattern') * name 'Lorna\'s Laces'           --> name ('Lorna\'s Laces') * </pre> *  * <p>If a method name ends in a number, that number will become * the first argument to that method call:</p>  * <pre> * k1                              --> k (1) * k1,p1,k2tog                     --> k (1); p (1); k2tog () * </pre> *  * <p>Maps are treated as whole arguments:</p> * <pre> * thickness unit:'wrap/in' 12     --> thickness (unit:'wrap/in',12) * </pre> *  */class KelToGroovy {	private String functionName	private def functionParameters = []	private StringBuffer outputLine	private StringBuffer pendingCharacters	private int parenCount = 0	private int braceCount = 0	private int bracketCount = 0		private boolean charWasSlash = false	private boolean lineComment = false		/**	 * Represents the character that is currently being used for quoting	 * (either single or double quote).  	 */	private def quoter = null	/**	 * Indicates whether the next characters is escaped in a quoted string  	 */	private boolean escaped = false		private boolean isColonizedClosure = false		/**	 * These characters will be broken out as individual tokens	 */ 	private final static char[] specialChars = ['{','(',')','}','[',']',',','"','\'','\\',':','/']	/**	 * 	 */	 protected def processToken(String token) {		 if (lineComment) {			 // handle special case of this being a line comment			 processNormalString(token)			 return		 }		 		 		 if (isBlank(token) && token?.length() > 0) {			 if (pendingCharacters != null) {				 if (quoter == null) {					 // whitespace not within quotes, so flush to stash					 flushToStash()				 } else {					 pendingCharacters << token				 }			 } else  {				 // preserve whitespace outside of function calls				 outputLine << token			 }			 charWasSlash = false		 } else if (indexOfAny(token, specialChars) > -1) {			 // split the token into special characters and non-special characters...			 // this ensures that all special characters are processed			 int specialCharPos = indexOfAny(token, specialChars) 			 processToken(token.substring(0,specialCharPos))			 processSpecialChar(token.charAt(specialCharPos))			 processToken(token.substring(specialCharPos + 1))		 } else if (!isBlank(token)){			 // process a string with no special characters in it			 charWasSlash = false			 processNormalString(token)		 }	 }		protected def processSpecialChar(Object ch) {		 if (quoter != null) {			 processQuotedChar(ch)		 } else {			 processUnquotedChar(ch)		 }	 }			protected def processQuotedChar(Object ch) {		switch (ch) {			case '\'':			case '"':				if (quoter == ch && !escaped) {					 // end quotes					 pendingCharacters << ch					 quoter = null				 } else {					 pendingCharacters << ch				 }				break			case '\\':				if (!escaped) {					escaped = true				} else {					escaped = false				}				// write out the backslash				pendingCharacters << ch				break			default:				pendingCharacters << ch				break		}		if (escaped && ch != '\\') {			escaped = false		}	}	 	protected def processUnquotedChar(Object ch) {		 if (ch == '(') {			 parenCount++		 } else if (ch == '{') {			 braceCount++			 writeFunction()			 outputLine << " " << ch		 } else if (ch == ')') {			 parenCount--		 } else if (ch == '}') {			 braceCount--			 writeFunction()			 outputLine << " " << ch		 } else if (ch == '[') {			 bracketCount++			 if (pendingCharacters == null) {				 pendingCharacters = new StringBuffer()			 }			 pendingCharacters << ch		 } else if (ch == ']') {			 bracketCount--			 pendingCharacters << ch		 } else if (ch == ',') {			 if (parenCount == 0 && bracketCount == 0) {				 // if not within parentheses, write the function and add a semicolon				 // (for functions like k 1, p 2 --> k (1); p (2)				 writeFunction()				 outputLine << ';'			 } else if (bracketCount == 0){				 // it's an argument in parentheses				 flushToStash()			 } else {				 // it's within a bracket... still constructing the parameter				 pendingCharacters << ch			 }		 } else if (ch == '\'' || ch == '"') {			 quoter = ch			 if (pendingCharacters == null) {				 pendingCharacters = new StringBuffer()			 }			 pendingCharacters << ch		 } else if (ch == ':') {			 boolean functionNameExisted = true		     if (functionName == null) {				 flushToStash()				 functionNameExisted = false			 }	     			 if (isColonizedFunctionName(functionName)) {				 braceCount++				 writeFunction()				 outputLine << " {"			     isColonizedClosure = true			 } else if (functionNameExisted) {				 processNormalString (String.valueOf(ch))			 } else {				 // lop off colon				 // such as --> description: ...			 }		} else if (ch == '/') {			if (charWasSlash) {				pendingCharacters = null // removes the previous '/' character, which we don't want to output yet				writeFunction()				lineComment = true				pendingCharacters = new StringBuffer()				// close the end brace if we were in a colonized closure BEFORE we write out the comment				if (isColonizedClosure) {					braceCount--					pendingCharacters << " } "					isColonizedClosure = false				}				pendingCharacters << '/' // puts the '/' character back			}			charWasSlash = true			if (pendingCharacters == null) {			  pendingCharacters = new StringBuffer()			}			pendingCharacters << ch		}	    if (ch != '/') {	    	charWasSlash = false	    }	}		     protected boolean isColonizedFunctionName(String funcName) {    	return funcName.equalsIgnoreCase("row") || funcName.equalsIgnoreCase("round") ||    	       funcName.equalsIgnoreCase("nextRow") || funcName.equalsIgnoreCase("shortRow") ||    	       funcName.equalsIgnoreCase("nextRound");    }	 	protected def processNormalString(String token) {		if (pendingCharacters == null) {			pendingCharacters = new StringBuffer()		}		if (quoter == null && !lineComment) {			if (token.equalsIgnoreCase("in")) {				// since "in" is a Groovy keyword and "in" means "inch",				// make "in" "inch"				pendingCharacters << "inch"			} else if (token.equalsIgnoreCase("for")) {				pendingCharacters << "fer"			} else {				pendingCharacters << token			}		} else {			pendingCharacters << token		}	}			protected def processFunctionName(String name) {				// if the function name ends in a number, extract that number and pass it as		// the first parameter to the function. Otherwise just return the original function name		int i		int startingPos = name.length() - 1		for (i = startingPos; i >= 0 && name.substring(i).isNumber(); i--) {		}				if (i < startingPos) {			functionName = StringUtils.uncapitalize(name.substring(0,i+1))			functionParameters << name.substring(i+1)		} else {			functionName = StringUtils.uncapitalize(name)		}	}		protected def flushToStash() {		if (pendingCharacters != null) {			if (functionName == null) {				processFunctionName(pendingCharacters.toString())			} else {				functionParameters << pendingCharacters.toString()			}			pendingCharacters = null		}	}			protected def writeFunction() {		 // before we write anything, flush any characters to our argument stash		 flushToStash()		 // if we have captured a function name, process it		 if (functionName != null) {			 def sb = new StringBuffer()			 sb << functionName			 // if there are parameters, add a space before the open parenthesis			 if (functionParameters.size() > 0) {				 sb << " "			 }			 if (!lineComment) {			   sb << "(" <<			       collectionToCommaDelimitedString(functionParameters) <<			       ")";			 }			 outputLine << sb		 }		 functionName = null		 functionParameters = []	 }	 	 String toGroovy(String text) {		 Writer writer = new StringWriter(text.size() + 50)		 toGroovy(new StringReader(text), writer)		 return writer.toString()	 }	 	 void toGroovy(Reader reader, Writer writer) {		 try {			 // transform each line and output it to the specified writer		     reader.transformLine (writer) {				 				 // it's a new line, so reset comment tracker				 charWasSlash = false				 lineComment = false				 				 // add 10 characters to the output StringBuffer (should be enough per line)		    	 outputLine = new StringBuffer(128)				 // tokenize on whitespace		    	 StringTokenizer st = new StringTokenizer(it, " \t\n\r\f", true)	    		 // process each token (including whitespace tokens) 		    	 while (st.hasMoreTokens()) {		    		 processToken(st.nextToken())		    	 }				 // if, after processing tokens on this line, the parentheses are balanced, write out the function.				 // Otherwise wait to write out the function until the parentheses are balanced.		    	 if (parenCount == 0) {		    		 writeFunction()		    	 }				 if (isColonizedClosure && !lineComment) {					 braceCount--					 outputLine << " }"					 isColonizedClosure = false				 }				 // results of the line processing are collected in outputLine; this will return				 // the value to the closure		    	 outputLine.toString()		     }		 } catch (Exception ex) {			 print writer.toString()			 throw ex		 }	}	}